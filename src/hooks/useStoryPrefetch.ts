'use client';

import useSWR, { preload, mutate } from 'swr';
import type { StorySlide } from '@/components/stories/StoryPlayer';
import type { UserPostedStory, AutoGeneratedStoryData } from './useUserStories';
import type { Task } from '@/types';

// =============================================================================
// TYPES
// =============================================================================

export interface StoryData {
  userPostedStories: UserPostedStory[];
  autoGeneratedData: AutoGeneratedStoryData | null;
  slides: StorySlide[];
  hasStory: boolean;
}

interface StoryAPIResponse {
  stories: UserPostedStory[];
  autoGeneratedData: AutoGeneratedStoryData | null;
  hasStory: boolean;
}

// =============================================================================
// CONSTANTS
// =============================================================================

const PREFETCH_WINDOW = 5; // Number of stories to prefetch ahead
const CACHE_DEDUPE_INTERVAL = 60 * 1000; // 1 minute - won't refetch within this window

// =============================================================================
// SLIDE BUILDER (mirrors useUserStories logic)
// Builds slides in CHRONOLOGICAL order (oldest first, newest last)
// =============================================================================

function buildSlides(
  userPostedStories: UserPostedStory[],
  autoGeneratedData: AutoGeneratedStoryData | null
): StorySlide[] {
  const result: StorySlide[] = [];

  // Auto-generated slides come first (they represent ongoing/base state)
  if (autoGeneratedData) {
    // 1. Goal slide (constant anchor - first)
    if (autoGeneratedData.goal) {
      result.push({
        id: 'goal',
        type: 'goal',
        data: {
          goalTitle: autoGeneratedData.goal.title,
          targetDate: autoGeneratedData.goal.targetDate,
          progress: autoGeneratedData.goal.progress,
        },
      });
    }

    // 2. Tasks slide (daily work)
    if (autoGeneratedData.tasks && autoGeneratedData.tasks.length > 0) {
      result.push({
        id: 'tasks',
        type: 'tasks',
        data: { tasks: autoGeneratedData.tasks },
      });
    }

    // 3. Day Closed slide (daily achievement)
    if (autoGeneratedData.hasDayClosed) {
      const actualCompletedTasks = autoGeneratedData.completedTasks?.length > 0 
        ? autoGeneratedData.completedTasks 
        : (autoGeneratedData.tasks || []).filter((t: Task) => t.status === 'completed');
      
      result.push({
        id: 'dayClosed',
        type: 'dayClosed',
        data: {
          completedTasks: actualCompletedTasks,
          tasksCompleted: autoGeneratedData.eveningCheckIn?.tasksCompleted || actualCompletedTasks.length,
          tasksTotal: autoGeneratedData.eveningCheckIn?.tasksTotal || (autoGeneratedData.tasks?.length || 0),
        },
      });
    }

    // 4. Week Closed slide (weekly achievement)
    if (autoGeneratedData.hasWeekClosed && autoGeneratedData.weeklyReflection) {
      result.push({
        id: 'weekClosed',
        type: 'weekClosed',
        data: {
          progressChange: autoGeneratedData.weeklyReflection.progressChange,
          publicFocus: autoGeneratedData.weeklyReflection.publicFocus,
        },
      });
    }
  }

  // 5. User-posted stories LAST, in chronological order (oldest â†’ newest)
  userPostedStories
    .sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime())
    .forEach((story) => {
      result.push({
        id: story.id, // Use the actual story ID
        type: 'user_post',
        data: {
          imageUrl: story.imageUrl,
          videoUrl: story.videoUrl,
          caption: story.caption,
          createdAt: story.createdAt,
          expiresAt: story.expiresAt,
        },
      });
    });

  return result;
}

// =============================================================================
// SWR FETCHER
// =============================================================================

/**
 * Fetches story data for a user and transforms it into StoryData
 */
async function storyFetcher(url: string): Promise<StoryData> {
  const response = await fetch(url);
  
  if (response.status === 403) {
    // Feed not enabled - return empty
    return {
      userPostedStories: [],
      autoGeneratedData: null,
      slides: [],
      hasStory: false,
    };
  }
  
  if (!response.ok) {
    throw new Error('Failed to fetch stories');
  }

  const data: StoryAPIResponse = await response.json();
  const userPostedStories = data.stories || [];
  const autoGeneratedData = data.autoGeneratedData || null;
  const slides = buildSlides(userPostedStories, autoGeneratedData);

  return {
    userPostedStories,
    autoGeneratedData,
    slides,
    hasStory: slides.length > 0,
  };
}

// =============================================================================
// CACHE KEY HELPER
// =============================================================================

function getStoryCacheKey(userId: string): string {
  return `/api/stories?userId=${userId}`;
}

// =============================================================================
// PREFETCH FUNCTIONS (can be called outside of React components)
// =============================================================================

/**
 * Prefetch a single user's story data into SWR cache
 * This can be called anywhere - doesn't need to be in a component
 */
export function prefetchStory(userId: string): void {
  if (!userId) return;
  const key = getStoryCacheKey(userId);
  preload(key, storyFetcher);
}

/**
 * Prefetch multiple users' stories
 * @param userIds - Array of user IDs to prefetch
 * @param startIndex - Starting index in the array
 * @param count - Number of stories to prefetch (default: 5)
 */
export function prefetchStories(
  userIds: string[],
  startIndex: number = 0,
  count: number = PREFETCH_WINDOW
): void {
  const endIndex = Math.min(startIndex + count, userIds.length);
  
  for (let i = startIndex; i < endIndex; i++) {
    const userId = userIds[i];
    if (userId) {
      prefetchStory(userId);
    }
  }
}

/**
 * Invalidate a user's story cache (forces refetch on next access)
 */
export function invalidateStoryCache(userId: string): void {
  if (!userId) return;
  const key = getStoryCacheKey(userId);
  mutate(key);
}

/**
 * Invalidate all story caches
 */
export function invalidateAllStoryCaches(): void {
  // Mutate all keys that match the story pattern
  mutate(
    (key) => typeof key === 'string' && key.startsWith('/api/stories?userId='),
    undefined,
    { revalidate: true }
  );
}

// =============================================================================
// HOOKS
// =============================================================================

/**
 * Hook to get story data for a specific user
 * Uses SWR for global caching - data persists across component mounts
 * 
 * @param userId - User ID to fetch stories for (null to skip)
 * @returns { data, isLoading, error, mutate }
 */
export function useStoryData(userId: string | null) {
  const key = userId ? getStoryCacheKey(userId) : null;
  
  const { data, error, isLoading, mutate: revalidate } = useSWR<StoryData>(
    key,
    storyFetcher,
    {
      revalidateOnFocus: false,
      revalidateOnReconnect: false,
      dedupingInterval: CACHE_DEDUPE_INTERVAL,
      keepPreviousData: true, // Show stale data while revalidating
    }
  );

  return {
    data: data || null,
    slides: data?.slides || [],
    hasStory: data?.hasStory || false,
    isLoading: isLoading && !data, // Only show loading if no cached data
    error: error?.message || null,
    revalidate,
  };
}

/**
 * Hook for managing story prefetching (backwards compatibility)
 * Now uses SWR under the hood for persistent caching
 */
export function useStoryPrefetch() {
  return {
    prefetchStories,
    prefetchStory,
    invalidateStoryCache,
    invalidateAllStoryCaches,
  };
}
