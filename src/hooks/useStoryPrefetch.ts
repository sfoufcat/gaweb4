'use client';

import useSWR, { preload, mutate } from 'swr';
import type { StorySlide } from '@/components/stories/StoryPlayer';
import type { UserPostedStory, AutoGeneratedStoryData } from './useUserStories';
import type { Task } from '@/types';

// =============================================================================
// TYPES
// =============================================================================

export interface StoryData {
  userPostedStories: UserPostedStory[];
  autoGeneratedData: AutoGeneratedStoryData | null;
  slides: StorySlide[];
  hasStory: boolean;
}

interface StoryAPIResponse {
  stories: UserPostedStory[];
  autoGeneratedData: AutoGeneratedStoryData | null;
  hasStory: boolean;
}

// =============================================================================
// CONSTANTS
// =============================================================================

const PREFETCH_WINDOW = 5; // Number of stories to prefetch ahead
const CACHE_DEDUPE_INTERVAL = 60 * 1000; // 1 minute - won't refetch within this window

// =============================================================================
// SLIDE BUILDER (mirrors useUserStories logic)
// Builds slides in CHRONOLOGICAL order (oldest first, newest last)
// All slides have timestamps and are sorted together
// =============================================================================

function getWeekStart(): string {
  const nowDate = new Date();
  const day = nowDate.getDay();
  const diff = nowDate.getDate() - day + (day === 0 ? -6 : 1);
  const monday = new Date(nowDate);
  monday.setDate(diff);
  monday.setHours(0, 0, 0, 0);
  return monday.toISOString();
}

function buildSlides(
  userPostedStories: UserPostedStory[],
  autoGeneratedData: AutoGeneratedStoryData | null
): StorySlide[] {
  const allSlides: StorySlide[] = [];
  const now = new Date().toISOString();

  if (autoGeneratedData) {
    // Goal slide - timestamp based on updatedAt or week start
    if (autoGeneratedData.goal) {
      const weekStart = autoGeneratedData.weekStartDate 
        ? new Date(autoGeneratedData.weekStartDate + 'T00:00:00').toISOString()
        : getWeekStart();
      
      // Use goal's updatedAt if available and newer than week start
      let goalTimestamp = weekStart;
      if (autoGeneratedData.goal.updatedAt) {
        const updatedAt = new Date(autoGeneratedData.goal.updatedAt);
        const weekStartDate = new Date(weekStart);
        if (updatedAt > weekStartDate) {
          goalTimestamp = autoGeneratedData.goal.updatedAt;
        }
      }
      
      allSlides.push({
        id: 'goal',
        type: 'goal',
        timestamp: goalTimestamp,
        data: {
          goalTitle: autoGeneratedData.goal.title,
          targetDate: autoGeneratedData.goal.targetDate,
          progress: autoGeneratedData.goal.progress,
        },
      });
    }

    // Tasks slide - timestamp based on most recent task
    if (autoGeneratedData.tasks && autoGeneratedData.tasks.length > 0) {
      const taskTimestamp = autoGeneratedData.latestTaskTimestamp || now;
      allSlides.push({
        id: 'tasks',
        type: 'tasks',
        timestamp: taskTimestamp,
        data: { tasks: autoGeneratedData.tasks },
      });
    }

    // Day Closed slide - timestamp from evening check-in
    if (autoGeneratedData.hasDayClosed) {
      const actualCompletedTasks = autoGeneratedData.completedTasks?.length > 0 
        ? autoGeneratedData.completedTasks 
        : (autoGeneratedData.tasks || []).filter((t: Task) => t.status === 'completed');
      
      const dayClosedTimestamp = autoGeneratedData.eveningCheckIn?.completedAt || now;
      allSlides.push({
        id: 'dayClosed',
        type: 'dayClosed',
        timestamp: dayClosedTimestamp,
        data: {
          completedTasks: actualCompletedTasks,
          tasksCompleted: autoGeneratedData.eveningCheckIn?.tasksCompleted || actualCompletedTasks.length,
          tasksTotal: autoGeneratedData.eveningCheckIn?.tasksTotal || (autoGeneratedData.tasks?.length || 0),
        },
      });
    }

    // Week Closed slide - timestamp from weekly reflection
    if (autoGeneratedData.hasWeekClosed && autoGeneratedData.weeklyReflection) {
      const weekClosedTimestamp = autoGeneratedData.weeklyReflection.completedAt || now;
      allSlides.push({
        id: 'weekClosed',
        type: 'weekClosed',
        timestamp: weekClosedTimestamp,
        data: {
          progressChange: autoGeneratedData.weeklyReflection.progressChange,
          publicFocus: autoGeneratedData.weeklyReflection.publicFocus,
        },
      });
    }
  }

  // User-posted stories with their createdAt as timestamp
  userPostedStories.forEach((story) => {
    allSlides.push({
      id: story.id,
      type: 'user_post',
      timestamp: story.createdAt,
      data: {
        imageUrl: story.imageUrl,
        videoUrl: story.videoUrl,
        caption: story.caption,
        createdAt: story.createdAt,
        expiresAt: story.expiresAt,
      },
    });
  });

  // Sort all slides by timestamp (oldest first, newest last)
  allSlides.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());

  return allSlides;
}

// =============================================================================
// SWR FETCHER
// =============================================================================

/**
 * Fetches story data for a user and transforms it into StoryData
 */
async function storyFetcher(url: string): Promise<StoryData> {
  const response = await fetch(url);
  
  if (response.status === 403) {
    // Feed not enabled - return empty
    return {
      userPostedStories: [],
      autoGeneratedData: null,
      slides: [],
      hasStory: false,
    };
  }
  
  if (!response.ok) {
    throw new Error('Failed to fetch stories');
  }

  const data: StoryAPIResponse = await response.json();
  const userPostedStories = data.stories || [];
  const autoGeneratedData = data.autoGeneratedData || null;
  const slides = buildSlides(userPostedStories, autoGeneratedData);

  return {
    userPostedStories,
    autoGeneratedData,
    slides,
    hasStory: slides.length > 0,
  };
}

// =============================================================================
// CACHE KEY HELPER
// =============================================================================

function getStoryCacheKey(userId: string): string {
  return `/api/stories?userId=${userId}`;
}

// =============================================================================
// PREFETCH FUNCTIONS (can be called outside of React components)
// =============================================================================

/**
 * Prefetch a single user's story data into SWR cache
 * This can be called anywhere - doesn't need to be in a component
 */
export function prefetchStory(userId: string): void {
  if (!userId) return;
  const key = getStoryCacheKey(userId);
  preload(key, storyFetcher);
}

/**
 * Prefetch multiple users' stories
 * @param userIds - Array of user IDs to prefetch
 * @param startIndex - Starting index in the array
 * @param count - Number of stories to prefetch (default: 5)
 */
export function prefetchStories(
  userIds: string[],
  startIndex: number = 0,
  count: number = PREFETCH_WINDOW
): void {
  const endIndex = Math.min(startIndex + count, userIds.length);
  
  for (let i = startIndex; i < endIndex; i++) {
    const userId = userIds[i];
    if (userId) {
      prefetchStory(userId);
    }
  }
}

/**
 * Invalidate a user's story cache (forces refetch on next access)
 */
export function invalidateStoryCache(userId: string): void {
  if (!userId) return;
  const key = getStoryCacheKey(userId);
  mutate(key);
}

/**
 * Invalidate all story caches
 */
export function invalidateAllStoryCaches(): void {
  // Mutate all keys that match the story pattern
  mutate(
    (key) => typeof key === 'string' && key.startsWith('/api/stories?userId='),
    undefined,
    { revalidate: true }
  );
}

// =============================================================================
// HOOKS
// =============================================================================

/**
 * Hook to get story data for a specific user
 * Uses SWR for global caching - data persists across component mounts
 * 
 * @param userId - User ID to fetch stories for (null to skip)
 * @returns { data, isLoading, error, mutate }
 */
export function useStoryData(userId: string | null) {
  const key = userId ? getStoryCacheKey(userId) : null;
  
  const { data, error, isLoading, mutate: revalidate } = useSWR<StoryData>(
    key,
    storyFetcher,
    {
      revalidateOnFocus: false,
      revalidateOnReconnect: false,
      dedupingInterval: CACHE_DEDUPE_INTERVAL,
      keepPreviousData: true, // Show stale data while revalidating
    }
  );

  return {
    data: data || null,
    slides: data?.slides || [],
    hasStory: data?.hasStory || false,
    isLoading: isLoading && !data, // Only show loading if no cached data
    error: error?.message || null,
    revalidate,
  };
}

/**
 * Hook for managing story prefetching (backwards compatibility)
 * Now uses SWR under the hood for persistent caching
 */
export function useStoryPrefetch() {
  return {
    prefetchStories,
    prefetchStory,
    invalidateStoryCache,
    invalidateAllStoryCaches,
  };
}
