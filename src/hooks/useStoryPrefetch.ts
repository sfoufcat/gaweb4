'use client';

import { useCallback, useRef, useEffect } from 'react';
import type { StorySlide } from '@/components/stories/StoryPlayer';
import type { UserPostedStory, AutoGeneratedStoryData } from './useUserStories';
import type { Task } from '@/types';

// =============================================================================
// TYPES
// =============================================================================

export interface PrefetchedStoryData {
  userPostedStories: UserPostedStory[];
  autoGeneratedData: AutoGeneratedStoryData | null;
  slides: StorySlide[];
  hasStory: boolean;
  fetchedAt: number;
}

interface StoryCache {
  [userId: string]: PrefetchedStoryData;
}

// =============================================================================
// CONSTANTS
// =============================================================================

const PREFETCH_WINDOW = 5; // Number of stories to prefetch ahead
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes cache TTL

// =============================================================================
// SLIDE BUILDER (mirrors useUserStories logic)
// =============================================================================

function buildSlides(
  userPostedStories: UserPostedStory[],
  autoGeneratedData: AutoGeneratedStoryData | null
): StorySlide[] {
  const result: StorySlide[] = [];

  // 1. Add user-posted stories first (newest first)
  userPostedStories
    .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
    .forEach((story) => {
      result.push({
        type: 'user_post',
        data: {
          id: story.id,
          imageUrl: story.imageUrl,
          videoUrl: story.videoUrl,
          caption: story.caption,
          createdAt: story.createdAt,
          expiresAt: story.expiresAt,
        },
      });
    });

  // 2. Add auto-generated stories from Firebase
  if (autoGeneratedData) {
    // Tasks slide
    if (autoGeneratedData.tasks && autoGeneratedData.tasks.length > 0) {
      result.push({
        type: 'tasks',
        data: { tasks: autoGeneratedData.tasks },
      });
    }

    // Day Closed slide
    if (autoGeneratedData.hasDayClosed) {
      const actualCompletedTasks = autoGeneratedData.completedTasks?.length > 0 
        ? autoGeneratedData.completedTasks 
        : (autoGeneratedData.tasks || []).filter((t: Task) => t.status === 'completed');
      
      result.push({
        type: 'dayClosed',
        data: {
          completedTasks: actualCompletedTasks,
          tasksCompleted: autoGeneratedData.eveningCheckIn?.tasksCompleted || actualCompletedTasks.length,
          tasksTotal: autoGeneratedData.eveningCheckIn?.tasksTotal || (autoGeneratedData.tasks?.length || 0),
        },
      });
    }

    // Week Closed slide
    if (autoGeneratedData.hasWeekClosed && autoGeneratedData.weeklyReflection) {
      result.push({
        type: 'weekClosed',
        data: {
          progressChange: autoGeneratedData.weeklyReflection.progressChange,
          publicFocus: autoGeneratedData.weeklyReflection.publicFocus,
        },
      });
    }

    // Goal slide (last, as the "anchor")
    if (autoGeneratedData.goal) {
      result.push({
        type: 'goal',
        data: {
          goalTitle: autoGeneratedData.goal.title,
          targetDate: autoGeneratedData.goal.targetDate,
          progress: autoGeneratedData.goal.progress,
        },
      });
    }
  }

  return result;
}

// =============================================================================
// HOOK
// =============================================================================

/**
 * Hook for prefetching story data for multiple users.
 * 
 * Features:
 * - Prefetches next N stories in the background while viewing current story
 * - Maintains an in-memory cache with TTL
 * - Provides instant access to cached story data
 * - Cleans up stale cache entries
 */
export function useStoryPrefetch() {
  const cacheRef = useRef<StoryCache>({});
  const pendingFetchesRef = useRef<Set<string>>(new Set());

  // Fetch story data for a single user
  const fetchStoryData = useCallback(async (userId: string): Promise<PrefetchedStoryData | null> => {
    // Skip if already being fetched
    if (pendingFetchesRef.current.has(userId)) {
      return null;
    }

    // Check cache first
    const cached = cacheRef.current[userId];
    if (cached && Date.now() - cached.fetchedAt < CACHE_TTL) {
      return cached;
    }

    // Mark as pending
    pendingFetchesRef.current.add(userId);

    try {
      const response = await fetch(`/api/stories?userId=${userId}`);
      
      if (response.status === 403) {
        // Feed not enabled - no stories
        const emptyData: PrefetchedStoryData = {
          userPostedStories: [],
          autoGeneratedData: null,
          slides: [],
          hasStory: false,
          fetchedAt: Date.now(),
        };
        cacheRef.current[userId] = emptyData;
        return emptyData;
      }
      
      if (!response.ok) {
        throw new Error('Failed to fetch stories');
      }

      const data = await response.json();
      const userPostedStories = data.stories || [];
      const autoGeneratedData = data.autoGeneratedData || null;
      const slides = buildSlides(userPostedStories, autoGeneratedData);

      const prefetchedData: PrefetchedStoryData = {
        userPostedStories,
        autoGeneratedData,
        slides,
        hasStory: slides.length > 0,
        fetchedAt: Date.now(),
      };

      cacheRef.current[userId] = prefetchedData;
      return prefetchedData;
    } catch (error) {
      console.error('[useStoryPrefetch] Error prefetching:', error);
      return null;
    } finally {
      pendingFetchesRef.current.delete(userId);
    }
  }, []);

  // Prefetch stories for multiple users starting from an index
  const prefetchStories = useCallback((
    userIds: string[],
    startIndex: number,
    count: number = PREFETCH_WINDOW
  ) => {
    const endIndex = Math.min(startIndex + count, userIds.length);
    
    for (let i = startIndex; i < endIndex; i++) {
      const userId = userIds[i];
      if (userId) {
        // Fire and forget - don't await
        fetchStoryData(userId);
      }
    }
  }, [fetchStoryData]);

  // Get cached story data (returns null if not cached)
  const getCachedStoryData = useCallback((userId: string): PrefetchedStoryData | null => {
    const cached = cacheRef.current[userId];
    if (cached && Date.now() - cached.fetchedAt < CACHE_TTL) {
      return cached;
    }
    return null;
  }, []);

  // Clear cache for a specific user
  const clearCache = useCallback((userId: string) => {
    delete cacheRef.current[userId];
  }, []);

  // Clear all cache
  const clearAllCache = useCallback(() => {
    cacheRef.current = {};
  }, []);

  // Cleanup stale cache entries periodically
  useEffect(() => {
    const interval = setInterval(() => {
      const now = Date.now();
      Object.entries(cacheRef.current).forEach(([userId, data]) => {
        if (now - data.fetchedAt > CACHE_TTL) {
          delete cacheRef.current[userId];
        }
      });
    }, 60 * 1000); // Cleanup every minute

    return () => clearInterval(interval);
  }, []);

  return {
    prefetchStories,
    fetchStoryData,
    getCachedStoryData,
    clearCache,
    clearAllCache,
  };
}

