'use client';

import { useState, useEffect, useCallback, useMemo } from 'react';
import type { StorySlide } from '@/components/stories/StoryPlayer';
import type { Task } from '@/types';

// =============================================================================
// TYPES
// =============================================================================

export interface UserPostedStory {
  id: string;
  type: 'user_post';
  authorId: string;
  imageUrl?: string;
  videoUrl?: string;
  caption?: string;
  expiresAt: string;
  createdAt: string;
}

export interface AutoGeneratedStoryData {
  tasks: Task[];
  goal: {
    title: string;
    targetDate: string;
    progress: number;
  } | null;
  hasDayClosed: boolean;
  completedTasks: Task[];
  eveningCheckIn: {
    emotionalState: string;
    tasksCompleted: number;
    tasksTotal: number;
  } | null;
  hasWeekClosed: boolean;
  weeklyReflection: {
    progressChange: number;
    publicFocus?: string;
  } | null;
}

export interface MergedStoryData {
  userPostedStories: UserPostedStory[];
  autoGeneratedData: AutoGeneratedStoryData | null;
  slides: StorySlide[];
  hasStory: boolean;
  isLoading: boolean;
  error: string | null;
}

// =============================================================================
// HOOK
// =============================================================================

/**
 * Hook to fetch and merge stories from both sources:
 * - User-posted stories from Stream (ephemeral, 24hr)
 * - Auto-generated stories from Firebase (tasks, goals, check-ins)
 * 
 * Returns a unified array of StorySlide[] for the StoryPlayer
 */
export function useUserStories(
  userId: string,
  firebaseStoryData?: AutoGeneratedStoryData
): MergedStoryData {
  const [userPostedStories, setUserPostedStories] = useState<UserPostedStory[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Fetch user-posted stories from Stream
  const fetchUserStories = useCallback(async () => {
    if (!userId) {
      setIsLoading(false);
      return;
    }

    try {
      const response = await fetch(`/api/stories?userId=${userId}`);
      
      if (response.status === 403) {
        // Feed not enabled - no user stories
        setUserPostedStories([]);
        return;
      }
      
      if (!response.ok) {
        throw new Error('Failed to fetch stories');
      }

      const data = await response.json();
      setUserPostedStories(data.stories || []);
      setError(null);
    } catch (err) {
      console.error('[useUserStories] Error fetching user stories:', err);
      setError(err instanceof Error ? err.message : 'Failed to fetch stories');
      setUserPostedStories([]);
    } finally {
      setIsLoading(false);
    }
  }, [userId]);

  // Fetch on mount and when userId changes
  useEffect(() => {
    fetchUserStories();
  }, [fetchUserStories]);

  // Build merged slides array
  const slides = useMemo(() => {
    const result: StorySlide[] = [];

    // 1. Add user-posted stories first (newest first)
    userPostedStories
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
      .forEach((story) => {
        result.push({
          type: 'user_post',
          data: {
            id: story.id,
            imageUrl: story.imageUrl,
            videoUrl: story.videoUrl,
            caption: story.caption,
            createdAt: story.createdAt,
            expiresAt: story.expiresAt,
          },
        });
      });

    // 2. Add auto-generated stories from Firebase (if provided)
    if (firebaseStoryData) {
      // Tasks slide
      if (firebaseStoryData.tasks.length > 0) {
        result.push({
          type: 'tasks',
          data: { tasks: firebaseStoryData.tasks },
        });
      }

      // Day Closed slide
      if (firebaseStoryData.hasDayClosed) {
        const actualCompletedTasks = firebaseStoryData.completedTasks.length > 0 
          ? firebaseStoryData.completedTasks 
          : firebaseStoryData.tasks.filter(t => t.status === 'completed');
        
        result.push({
          type: 'dayClosed',
          data: {
            completedTasks: actualCompletedTasks,
            tasksCompleted: firebaseStoryData.eveningCheckIn?.tasksCompleted || actualCompletedTasks.length,
            tasksTotal: firebaseStoryData.eveningCheckIn?.tasksTotal || firebaseStoryData.tasks.length,
          },
        });
      }

      // Week Closed slide
      if (firebaseStoryData.hasWeekClosed && firebaseStoryData.weeklyReflection) {
        result.push({
          type: 'weekClosed',
          data: {
            progressChange: firebaseStoryData.weeklyReflection.progressChange,
            publicFocus: firebaseStoryData.weeklyReflection.publicFocus,
          },
        });
      }

      // Goal slide (last, as the "anchor")
      if (firebaseStoryData.goal) {
        result.push({
          type: 'goal',
          data: {
            goalTitle: firebaseStoryData.goal.title,
            targetDate: firebaseStoryData.goal.targetDate,
            progress: firebaseStoryData.goal.progress,
          },
        });
      }
    }

    return result;
  }, [userPostedStories, firebaseStoryData]);

  // Determine if user has any story
  const hasStory = slides.length > 0;

  return {
    userPostedStories,
    autoGeneratedData: firebaseStoryData || null,
    slides,
    hasStory,
    isLoading,
    error,
  };
}

/**
 * Hook for the current user to create stories
 */
export function useCreateStory() {
  const [isCreating, setIsCreating] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const createStory = useCallback(async (data: {
    imageUrl?: string;
    videoUrl?: string;
    caption?: string;
  }) => {
    setIsCreating(true);
    setError(null);

    try {
      const response = await fetch('/api/stories', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to create story');
      }

      const result = await response.json();
      return result.story as UserPostedStory;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to create story';
      setError(errorMessage);
      throw err;
    } finally {
      setIsCreating(false);
    }
  }, []);

  return {
    createStory,
    isCreating,
    error,
  };
}

/**
 * Simplified hook to check if any user in an array has stories
 * Used for the story avatar row to show which users have content
 */
export function useMultipleUserStories(userIds: string[]) {
  const [storiesMap, setStoriesMap] = useState<Map<string, boolean>>(new Map());
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchAll = async () => {
      if (userIds.length === 0) {
        setIsLoading(false);
        return;
      }

      const results = new Map<string, boolean>();
      
      // Fetch in parallel (batch of 5 at a time to avoid overwhelming)
      const batches = [];
      for (let i = 0; i < userIds.length; i += 5) {
        batches.push(userIds.slice(i, i + 5));
      }

      for (const batch of batches) {
        await Promise.all(
          batch.map(async (userId) => {
            try {
              const response = await fetch(`/api/stories?userId=${userId}`);
              if (response.ok) {
                const data = await response.json();
                results.set(userId, (data.stories?.length || 0) > 0);
              } else {
                results.set(userId, false);
              }
            } catch {
              results.set(userId, false);
            }
          })
        );
      }

      setStoriesMap(results);
      setIsLoading(false);
    };

    fetchAll();
  }, [userIds.join(',')]); // Re-run when user list changes

  return {
    storiesMap,
    isLoading,
    hasStory: (userId: string) => storiesMap.get(userId) || false,
  };
}

