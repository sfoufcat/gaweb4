'use client';

import { useState, useEffect, useCallback, useMemo } from 'react';
import type { StorySlide } from '@/components/stories/StoryPlayer';
import type { Task } from '@/types';

// =============================================================================
// TYPES
// =============================================================================

export interface UserPostedStory {
  id: string;
  type: 'user_post';
  authorId: string;
  imageUrl?: string;
  videoUrl?: string;
  caption?: string;
  expiresAt: string;
  createdAt: string;
}

export interface AutoGeneratedStoryData {
  tasks: Task[];
  goal: {
    title: string;
    targetDate: string;
    progress: number;
    updatedAt?: string | null;
  } | null;
  hasDayClosed: boolean;
  completedTasks: Task[];
  eveningCheckIn: {
    emotionalState: string;
    tasksCompleted: number;
    tasksTotal: number;
    completedAt?: string | null;
  } | null;
  hasWeekClosed: boolean;
  weeklyReflection: {
    progressChange: number;
    publicFocus?: string;
    completedAt?: string | null;
  } | null;
  // Timestamps for chronological ordering
  latestTaskTimestamp?: string | null;
  weekStartDate?: string;
}

export interface MergedStoryData {
  userPostedStories: UserPostedStory[];
  autoGeneratedData: AutoGeneratedStoryData | null;
  slides: StorySlide[];
  hasStory: boolean;
  isLoading: boolean;
  error: string | null;
}

// =============================================================================
// HOOK
// =============================================================================

/**
 * Hook to fetch and merge stories from both sources:
 * - User-posted stories from Firestore (ephemeral, 24hr)
 * - Auto-generated stories from Firebase (tasks, goals, check-ins)
 * 
 * Returns a unified array of StorySlide[] for the StoryPlayer.
 * 
 * The API now returns both sources in one call, so we don't need
 * firebaseStoryData passed in separately.
 */
export function useUserStories(userId: string): MergedStoryData {
  const [userPostedStories, setUserPostedStories] = useState<UserPostedStory[]>([]);
  const [autoGeneratedData, setAutoGeneratedData] = useState<AutoGeneratedStoryData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Reset loading state immediately when userId changes
  useEffect(() => {
    if (userId) {
      setIsLoading(true);
      setUserPostedStories([]);
      setAutoGeneratedData(null);
    } else {
      setIsLoading(false);
    }
  }, [userId]);

  // Fetch all stories (user-posted + auto-generated) from API
  const fetchStories = useCallback(async () => {
    if (!userId) {
      return;
    }

    try {
      const response = await fetch(`/api/stories?userId=${userId}`);
      
      if (response.status === 403) {
        // Feed not enabled - no stories
        setUserPostedStories([]);
        setAutoGeneratedData(null);
        return;
      }
      
      if (!response.ok) {
        throw new Error('Failed to fetch stories');
      }

      const data = await response.json();
      setUserPostedStories(data.stories || []);
      setAutoGeneratedData(data.autoGeneratedData || null);
      setError(null);
    } catch (err) {
      console.error('[useUserStories] Error fetching stories:', err);
      setError(err instanceof Error ? err.message : 'Failed to fetch stories');
      setUserPostedStories([]);
      setAutoGeneratedData(null);
    } finally {
      setIsLoading(false);
    }
  }, [userId]);

  // Fetch on mount and when userId changes
  useEffect(() => {
    if (userId) {
      fetchStories();
    }
  }, [userId, fetchStories]);

  // Build merged slides array in CHRONOLOGICAL order (oldest first, newest last)
  // All slides have timestamps and are sorted together for proper ordering
  const slides = useMemo(() => {
    const allSlides: StorySlide[] = [];
    const now = new Date().toISOString();
    
    // Get week start (Monday) for goal timestamp fallback
    const getWeekStart = (): string => {
      const nowDate = new Date();
      const day = nowDate.getDay();
      const diff = nowDate.getDate() - day + (day === 0 ? -6 : 1);
      const monday = new Date(nowDate);
      monday.setDate(diff);
      monday.setHours(0, 0, 0, 0);
      return monday.toISOString();
    };

    if (autoGeneratedData) {
      // Goal slide - timestamp based on updatedAt or week start
      // Goal is "new" if it was updated this week or if the week changed
      if (autoGeneratedData.goal) {
        const weekStart = autoGeneratedData.weekStartDate 
          ? new Date(autoGeneratedData.weekStartDate + 'T00:00:00').toISOString()
          : getWeekStart();
        
        // Use goal's updatedAt if available and newer than week start, otherwise use week start
        let goalTimestamp = weekStart;
        if (autoGeneratedData.goal.updatedAt) {
          const updatedAt = new Date(autoGeneratedData.goal.updatedAt);
          const weekStartDate = new Date(weekStart);
          if (updatedAt > weekStartDate) {
            goalTimestamp = autoGeneratedData.goal.updatedAt;
          }
        }
        
        allSlides.push({
          id: 'goal',
          type: 'goal',
          timestamp: goalTimestamp,
          data: {
            goalTitle: autoGeneratedData.goal.title,
            targetDate: autoGeneratedData.goal.targetDate,
            progress: autoGeneratedData.goal.progress,
          },
        });
      }

      // Tasks slide - timestamp based on most recent task
      if (autoGeneratedData.tasks && autoGeneratedData.tasks.length > 0) {
        const taskTimestamp = autoGeneratedData.latestTaskTimestamp || now;
        allSlides.push({
          id: 'tasks',
          type: 'tasks',
          timestamp: taskTimestamp,
          data: { tasks: autoGeneratedData.tasks },
        });
      }

      // Day Closed slide - timestamp from evening check-in
      if (autoGeneratedData.hasDayClosed) {
        const actualCompletedTasks = autoGeneratedData.completedTasks?.length > 0 
          ? autoGeneratedData.completedTasks 
          : (autoGeneratedData.tasks || []).filter(t => t.status === 'completed');
        
        const dayClosedTimestamp = autoGeneratedData.eveningCheckIn?.completedAt || now;
        allSlides.push({
          id: 'dayClosed',
          type: 'dayClosed',
          timestamp: dayClosedTimestamp,
          data: {
            completedTasks: actualCompletedTasks,
            tasksCompleted: autoGeneratedData.eveningCheckIn?.tasksCompleted || actualCompletedTasks.length,
            tasksTotal: autoGeneratedData.eveningCheckIn?.tasksTotal || (autoGeneratedData.tasks?.length || 0),
          },
        });
      }

      // Week Closed slide - timestamp from weekly reflection
      if (autoGeneratedData.hasWeekClosed && autoGeneratedData.weeklyReflection) {
        const weekClosedTimestamp = autoGeneratedData.weeklyReflection.completedAt || now;
        allSlides.push({
          id: 'weekClosed',
          type: 'weekClosed',
          timestamp: weekClosedTimestamp,
          data: {
            progressChange: autoGeneratedData.weeklyReflection.progressChange,
            publicFocus: autoGeneratedData.weeklyReflection.publicFocus,
          },
        });
      }
    }

    // User-posted stories with their createdAt as timestamp
    userPostedStories.forEach((story) => {
      allSlides.push({
        id: story.id,
        type: 'user_post',
        timestamp: story.createdAt,
        data: {
          imageUrl: story.imageUrl,
          videoUrl: story.videoUrl,
          caption: story.caption,
          createdAt: story.createdAt,
          expiresAt: story.expiresAt,
        },
      });
    });

    // Sort all slides by timestamp (oldest first, newest last)
    allSlides.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());

    return allSlides;
  }, [userPostedStories, autoGeneratedData]);

  // Determine if user has any story
  const hasStory = slides.length > 0;

  return {
    userPostedStories,
    autoGeneratedData,
    slides,
    hasStory,
    isLoading,
    error,
  };
}

/**
 * Hook for the current user to create stories
 */
export function useCreateStory() {
  const [isCreating, setIsCreating] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const createStory = useCallback(async (data: {
    imageUrl?: string;
    videoUrl?: string;
    caption?: string;
  }) => {
    setIsCreating(true);
    setError(null);

    try {
      const response = await fetch('/api/stories', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to create story');
      }

      const result = await response.json();
      return result.story as UserPostedStory;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to create story';
      setError(errorMessage);
      throw err;
    } finally {
      setIsCreating(false);
    }
  }, []);

  return {
    createStory,
    isCreating,
    error,
  };
}

/**
 * Simplified hook to check if any user in an array has stories
 * Used for the story avatar row to show which users have content
 */
export function useMultipleUserStories(userIds: string[]) {
  const [storiesMap, setStoriesMap] = useState<Map<string, boolean>>(new Map());
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchAll = async () => {
      if (userIds.length === 0) {
        setIsLoading(false);
        return;
      }

      const results = new Map<string, boolean>();
      
      // Fetch in parallel (batch of 5 at a time to avoid overwhelming)
      const batches = [];
      for (let i = 0; i < userIds.length; i += 5) {
        batches.push(userIds.slice(i, i + 5));
      }

      for (const batch of batches) {
        await Promise.all(
          batch.map(async (userId) => {
            try {
              const response = await fetch(`/api/stories?userId=${userId}`);
              if (response.ok) {
                const data = await response.json();
                // hasStory includes both user-posted AND auto-generated stories
                results.set(userId, data.hasStory === true);
              } else {
                results.set(userId, false);
              }
            } catch {
              results.set(userId, false);
            }
          })
        );
      }

      setStoriesMap(results);
      setIsLoading(false);
    };

    fetchAll();
  }, [userIds.join(',')]); // Re-run when user list changes

  return {
    storiesMap,
    isLoading,
    hasStory: (userId: string) => storiesMap.get(userId) || false,
  };
}

