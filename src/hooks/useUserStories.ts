'use client';

import { useState, useEffect, useCallback, useMemo } from 'react';
import type { StorySlide } from '@/components/stories/StoryPlayer';
import type { Task } from '@/types';

// =============================================================================
// TYPES
// =============================================================================

export interface UserPostedStory {
  id: string;
  type: 'user_post';
  authorId: string;
  imageUrl?: string;
  videoUrl?: string;
  caption?: string;
  expiresAt: string;
  createdAt: string;
}

export interface AutoGeneratedStoryData {
  tasks: Task[];
  goal: {
    title: string;
    targetDate: string;
    progress: number;
  } | null;
  hasDayClosed: boolean;
  completedTasks: Task[];
  eveningCheckIn: {
    emotionalState: string;
    tasksCompleted: number;
    tasksTotal: number;
  } | null;
  hasWeekClosed: boolean;
  weeklyReflection: {
    progressChange: number;
    publicFocus?: string;
  } | null;
}

export interface MergedStoryData {
  userPostedStories: UserPostedStory[];
  autoGeneratedData: AutoGeneratedStoryData | null;
  slides: StorySlide[];
  hasStory: boolean;
  isLoading: boolean;
  error: string | null;
}

// =============================================================================
// HOOK
// =============================================================================

/**
 * Hook to fetch and merge stories from both sources:
 * - User-posted stories from Firestore (ephemeral, 24hr)
 * - Auto-generated stories from Firebase (tasks, goals, check-ins)
 * 
 * Returns a unified array of StorySlide[] for the StoryPlayer.
 * 
 * The API now returns both sources in one call, so we don't need
 * firebaseStoryData passed in separately.
 */
export function useUserStories(userId: string): MergedStoryData {
  const [userPostedStories, setUserPostedStories] = useState<UserPostedStory[]>([]);
  const [autoGeneratedData, setAutoGeneratedData] = useState<AutoGeneratedStoryData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Reset loading state immediately when userId changes
  useEffect(() => {
    if (userId) {
      setIsLoading(true);
      setUserPostedStories([]);
      setAutoGeneratedData(null);
    } else {
      setIsLoading(false);
    }
  }, [userId]);

  // Fetch all stories (user-posted + auto-generated) from API
  const fetchStories = useCallback(async () => {
    if (!userId) {
      return;
    }

    try {
      const response = await fetch(`/api/stories?userId=${userId}`);
      
      if (response.status === 403) {
        // Feed not enabled - no stories
        setUserPostedStories([]);
        setAutoGeneratedData(null);
        return;
      }
      
      if (!response.ok) {
        throw new Error('Failed to fetch stories');
      }

      const data = await response.json();
      setUserPostedStories(data.stories || []);
      setAutoGeneratedData(data.autoGeneratedData || null);
      setError(null);
    } catch (err) {
      console.error('[useUserStories] Error fetching stories:', err);
      setError(err instanceof Error ? err.message : 'Failed to fetch stories');
      setUserPostedStories([]);
      setAutoGeneratedData(null);
    } finally {
      setIsLoading(false);
    }
  }, [userId]);

  // Fetch on mount and when userId changes
  useEffect(() => {
    if (userId) {
      fetchStories();
    }
  }, [userId, fetchStories]);

  // Build merged slides array in CHRONOLOGICAL order (oldest first, newest last)
  // This allows users to resume where they left off
  const slides = useMemo(() => {
    const result: StorySlide[] = [];

    // Auto-generated slides come first (they represent ongoing/base state)
    if (autoGeneratedData) {
      // 1. Goal slide (constant anchor - first)
      if (autoGeneratedData.goal) {
        result.push({
          id: 'goal',
          type: 'goal',
          data: {
            goalTitle: autoGeneratedData.goal.title,
            targetDate: autoGeneratedData.goal.targetDate,
            progress: autoGeneratedData.goal.progress,
          },
        });
      }

      // 2. Tasks slide (daily work)
      if (autoGeneratedData.tasks && autoGeneratedData.tasks.length > 0) {
        result.push({
          id: 'tasks',
          type: 'tasks',
          data: { tasks: autoGeneratedData.tasks },
        });
      }

      // 3. Day Closed slide (daily achievement)
      if (autoGeneratedData.hasDayClosed) {
        const actualCompletedTasks = autoGeneratedData.completedTasks?.length > 0 
          ? autoGeneratedData.completedTasks 
          : (autoGeneratedData.tasks || []).filter(t => t.status === 'completed');
        
        result.push({
          id: 'dayClosed',
          type: 'dayClosed',
          data: {
            completedTasks: actualCompletedTasks,
            tasksCompleted: autoGeneratedData.eveningCheckIn?.tasksCompleted || actualCompletedTasks.length,
            tasksTotal: autoGeneratedData.eveningCheckIn?.tasksTotal || (autoGeneratedData.tasks?.length || 0),
          },
        });
      }

      // 4. Week Closed slide (weekly achievement)
      if (autoGeneratedData.hasWeekClosed && autoGeneratedData.weeklyReflection) {
        result.push({
          id: 'weekClosed',
          type: 'weekClosed',
          data: {
            progressChange: autoGeneratedData.weeklyReflection.progressChange,
            publicFocus: autoGeneratedData.weeklyReflection.publicFocus,
          },
        });
      }
    }

    // 5. User-posted stories LAST, in chronological order (oldest â†’ newest)
    userPostedStories
      .sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime())
      .forEach((story) => {
        result.push({
          id: story.id, // Use the actual story ID
          type: 'user_post',
          data: {
            imageUrl: story.imageUrl,
            videoUrl: story.videoUrl,
            caption: story.caption,
            createdAt: story.createdAt,
            expiresAt: story.expiresAt,
          },
        });
      });

    return result;
  }, [userPostedStories, autoGeneratedData]);

  // Determine if user has any story
  const hasStory = slides.length > 0;

  return {
    userPostedStories,
    autoGeneratedData,
    slides,
    hasStory,
    isLoading,
    error,
  };
}

/**
 * Hook for the current user to create stories
 */
export function useCreateStory() {
  const [isCreating, setIsCreating] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const createStory = useCallback(async (data: {
    imageUrl?: string;
    videoUrl?: string;
    caption?: string;
  }) => {
    setIsCreating(true);
    setError(null);

    try {
      const response = await fetch('/api/stories', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to create story');
      }

      const result = await response.json();
      return result.story as UserPostedStory;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to create story';
      setError(errorMessage);
      throw err;
    } finally {
      setIsCreating(false);
    }
  }, []);

  return {
    createStory,
    isCreating,
    error,
  };
}

/**
 * Simplified hook to check if any user in an array has stories
 * Used for the story avatar row to show which users have content
 */
export function useMultipleUserStories(userIds: string[]) {
  const [storiesMap, setStoriesMap] = useState<Map<string, boolean>>(new Map());
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchAll = async () => {
      if (userIds.length === 0) {
        setIsLoading(false);
        return;
      }

      const results = new Map<string, boolean>();
      
      // Fetch in parallel (batch of 5 at a time to avoid overwhelming)
      const batches = [];
      for (let i = 0; i < userIds.length; i += 5) {
        batches.push(userIds.slice(i, i + 5));
      }

      for (const batch of batches) {
        await Promise.all(
          batch.map(async (userId) => {
            try {
              const response = await fetch(`/api/stories?userId=${userId}`);
              if (response.ok) {
                const data = await response.json();
                // hasStory includes both user-posted AND auto-generated stories
                results.set(userId, data.hasStory === true);
              } else {
                results.set(userId, false);
              }
            } catch {
              results.set(userId, false);
            }
          })
        );
      }

      setStoriesMap(results);
      setIsLoading(false);
    };

    fetchAll();
  }, [userIds.join(',')]); // Re-run when user list changes

  return {
    storiesMap,
    isLoading,
    hasStory: (userId: string) => storiesMap.get(userId) || false,
  };
}

